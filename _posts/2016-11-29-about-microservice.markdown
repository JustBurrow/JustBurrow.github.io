---
layout: post
title: Microservice architecture에 관한 잡생각
---

> 이 포스트는 수 많은 억측과 상상과 착각으로 버무린 소설임을 밝힙니다.
> 이 소설을 있는 그대로 믿었을 경우 생길 수도 있는 부끄러움은 당신의 몫입니다.

C 프로그래밍을 거의 하지 않았기 때문에, 아는 바 거의 없는 시대이지만, 어쨌든 과거에 Procedure 프로그래밍이 있었다. 물론 어셈블리나 기계어의 시대도 있었지만 그건 거의 선사시대에 메머드 똥침놓던 시절의 느낌이니 빼자. 손바닥 터져라 비벼서 불피우는 건 재미나 특수한 환경 때문에 하는 거지 일상 생활은 아니다.

어쨌거나 프로시듀어 프로그래밍이 있었고 개발과 개선의 결과, 많은 소스코드가 요즘 우리가 OOP가 뭔지도 모르는 자가 써갈긴 거라고 욕하는 바로 그 스파게티 메서드 처럼 무수한 분기문가 반복문의 합체를 C&P 해놓은 그런 괴물이었을 것이다. 개발자를 덮쳐 악취를 풍기며 퇴근을 잡아먹으며 과로사를 일으키는 괴물.

IT 업계가 성장하면서 소프트웨어의 수도, 하나의 소프트웨어의 크기도 커졌고 개발의 복잡성은 더더욱 커졌다. 이런 복잡성은 직접 개발한 당사자가 아니면 손댈 수 없는, 도움을 구할 수도 인수인계를 할 수도 없는 상태로 돌진했고, 아마도 순진했던 개발자는 급여와 계약에 묶여 수명을 팔다가 생명력을 팔아야 하는 처지가 됐다. 실무에 파뭍혀 정치질을 할 수 없었으니 상황의 악화를 막을 기회도 잡지 못했다. 그러다 더러는 생명력이 바닥나고 말았다. 개발자는 살아야 했다.

소프트웨어 개발이란 기본적으로 어려운 일이다. 인간의 방식이 아닌 기계의 방식으로 생각해야 할 수 있는 일이니까. 사고방식을 바꾸는 것은 정말 어렵다. 천동설의 사고방식은 지동설의 사고방식으로 바꾸는 것은 성공했어도, 나이가 몇 살 많거나 적은 사람의 가치기준은 이해하지 못한다.

## 재사용성

어쨌거나, 그런 어려움을 조금이라도 줄여보고자 무수한 노력을 기울였다. 그리고 그 노력은 한 마디로 "재사용성을 높이려는 노력"이라고 정리할 수 있다.

그렇다. 우리는 재사용성을 조금이라도 끌어올려보고자 무수한 삽을 푸는 것이다. 변수와 함수를 재사용 해보고자 OOP라는 개념을 개발했고, SOLID나 DRY 같은 원칙을 만들고, 여러 단계와 분기와 반복을 한번에 재사용 해보고자 모듈과 라이브러리를 만들고, 다른 소프트웨어를 재사용하자고 컴포넌트(CBD)륾 만들고, 서버 단위로 재사용 해보고자 SOA를 만들었다.

그리고 그동안 개발 프로젝트의 수도 늘었고, 각 프로젝트의 소스코드 크기도 늘었다. OOP를 조금이라도 안다면 모듈과 타입을 만들었으니 이것도 늘었고, 라이브러리도 늘었다.

그렇다. 급여 빼고 다 늘었다.

## 복잡성

소프트웨어란 복잡하다. 그거 뭐 별거 아니네 하는 소리를 들으면 그건 그냥 무식한 거 숨겨보고자 하는 처량한 몸부림이다. 아니면 당신에게 일폭탄을 떨구려는 가증스러운 짓거리일 뿐이다. 만약 업계 사람이라면 블랙리스트에 올리고, 그런 사람이 회사에서 요직을 차지하고 있다면 회사도 블랙리스트에 올려라. 그럼에도 불구하고 회사가 흑자이고 적자전환할 것 같지 않고 당신이 매우 지친 상태라면, 이빨을 잘 가다듬어라. 당신을 위해 준비되어있는 꿀보직, 땡보의 자리가 그안 어딘가에 있다. 알흠다운 이빨로 그 자리를 차지하라. 아니면, 도망쳐라. 어물쩡거리는 사이 먼저 도망친 자들이 자신의 블랙리스트를 까고 난 뒤면 늦는다.

다시 가지를 치고.

소프트웨어는 복잡하다. 불평하지 말아라. 원래 타고 나기를 그런 거다. 만약 쉽다고 느낀다면 당신은 이거 읽고 있을 시간에 개발을 하는 게 인류의 행복을 위해 나은 선택일 천재란 뜻이다. 사기치지 말고 정의와 소소한 삶의 행복에 대한 애정을 잃지 말길 바란다. 당신이 천재가 아님에도 불구하고 개발이 쉽다면, 당신이 잠든 사이애 X뺑이 친 개발자가 많다는 뜻이다. 앞서 간 이들에게 감사하라.

소프트웨어는 개발은 복잡하다. 그리고 운영하는 것도 복잡하다. 개발과 운영은 일반적으로 트레이드오프 관계이다. 개발이 편하면 운영이 힘들고, 개발이 힘들면 운영이 어렵다. 단적인 예가 의존성 관리다. 개발이 힘들게 다 개발하면 의존성 관리 필요없다. 반대는 길고긴 텍스트로 의존성을 관리해야 한다.

운영이 처음 시작될 때, 스케일업(HW 성능 향상)을 먼저 했다 - 아마도. 당장 애플리케이션 하나 돌리는 것도 버거워하는 컴퓨터란 성능 향상이 급하니까. SLI든 크로스파이어든 GPU가 어느 수준은 나온 다음의 소리인 것처럼. 그 후에 하드웨어를 실행할 애플리케이션에 따라 티어를 나누고 이들을 네트워크로 연결했다. 그냥 느낌적 느낌인 정도로 해두자. 나도 저 둘이 앞서거니 뒤서거니 한 거 안다.

개별 서버의 성능이 높아지고 네트워크의 성능도 높아졌다. 그런데 문제는, 네트워크 성능이 높아진다는 건 속도가 빠르다는 소리일 뿐만 아니라, 네트워크에 속하는 컴퓨터의 숫자도 늘어난다는 뜻이다. 네트워크 담당자가 관리해야 할 게 늘어났다. 그리고 이때 경영자 혹은 (자칭) 차기 경영자가 나타나 외친다. **경비절감!!!**

그래서 부하가 큰 작업을 담당하는 애플리케이션은 성능이 좋은 컴퓨터에 할당하고, 역할에 맞게 네트워크 연결을 바꿔주면서, 적절하게 대역폭을 확보해야 한다. 그러니까, `CPU vs 로컬IO vs 네트워크IO`의 리소스 요구(경비절감!)에 맞춰 최적화를 진행해야 한다. 아... 네트워크 담당자의 생명력이 빠르게 갈려나갑니다.
